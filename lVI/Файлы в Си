                      Работа с файлами в си

Файл - это единица хранения данных, которые обычно хранятся на винчестерах (жестких дисках). Будем рассматривать как последовательный, так и произвольный доступ к файлу. 

В языке Си любой файл рассматривается как поток байтов. Концом любого файла является спец. символ. При открытии файла, ему ставится определенный поток и возвращается указатель на структуру FILE (так же возвращаемое значение именуют - дескриптор файла). Т.е. доступ к элементам файла будет происходить с помощью этого указателя.

Рассмотрим программу работы с файломи в си ( ввод имени и балла ):

#include <conio.h>
#include <stdio.h>

int main()
{
     int bal;
     char name[15];
     FILE *file;

     if ((file = fopen("1.txt","w")) == NULL)
        printf("Файл невозможно открыть или создать\n");
     else{
        for(;;){
           scanf ("%d%s", &bal, name);
           if (bal == 0)
              break;
           fprintf(file,"%d %s\n", bal, name);
        }
     }
     fclose(file);
return 0;
}

проведем подробный анализ данной программы:

   Cтруктура file ( дескриптор файла )

FILE *file;

объявляем указатель на структуру FILE ( дескриптор файла ). Структура - это особый тип данных. Т.е. для доступа к файлу нам необходимо иметь указатель на файл ( дескриптор файла ), и со всеми файлами работает эта структура.

if ((file = fopen("1.txt","w")) == NULL)

функция fopen принимает два параметра. Первый - это имя файла, второй - режим работы с файлом, в котором он будет открыт. В нашем режиме, если файл не существует, то он создается, а если файл уже был, то его содержимое полностью стирается. Эта функция возвращает указатель на структуру FILE ( дескриптор файла ), т.е. теперь можно управлять созданным файлом при помощи нашего указателя file. Оператор if тут используется, так как идет проверка указателя на NULL, а NULL может быть, только если файл мы не смогли открыть.

fprintf(file,"%d %s\n", bal, name);

оператор записывает данные в файл. Принцип действия тот же, какой и у оператора printf, только тут в начале указывается указатель на файл ( дескриптор файла ), в который будет производится запись данных.

fclose(file);

раз данные записали и файл больше не нужен, то можно закрывать его, тем самым освобождая ресурсы. 


Разберем режимы открытия:

   1. r      открываем файл для чтения

   2. w      создаем файл для записи. Если файл уже существует, 
             то стираем все данные

   3. a      создаем файл для записи. Если файл уже существует, 
             то записываем данные в конец файла

   4. r+     открываем файл для записи и чтения

   5. w+     создаем файл для обновления. Если файл уже существует, 
             то данные стираются

   6. а+     создает файл для обновления. Если файл существует, 
             то данные  записываются в конец файла


Прочитать с файла.

#include <conio.h>
#include <stdio.h>

int main()
{
     int bal;
     char name[15];
     FILE *file;

     if ((file = fopen("1.txt","r")) == NULL)
        printf("Файл невозможно открыть или создать\n");
     else{
        for(;;){
           if (feof(file))
              break;
           fscanf(file,"%d %s", &bal, name);
           printf ("%d %s\n", bal, name);
        }
     }
     fclose(file);
     getch();
return 0;
}

Разберем отличия записи в файл и чтения из файла:

if ((file = fopen("1.txt","r")) == NULL)

открывает файл в режиме чтения. 

if (feof(file))

проверяет условие окончания файла. В случае, когда все файлы будут считаны, сработает наша структура и выполнит операцию break

fscanf(file,"%d %s", &bal, name);

считывает данные из файла и записывает их в указанные переменные. Действует, так же как и функция scanf(), только считывает введенные данные не с экрана, а с файла.


Файлы произвольного доступа

Созданные данные с помощью функции fprintf не обязательно должны быть одинаковой длины. Данные, которые создаются в файле с произвольным доступом, имеют определенную длину, что позволяет быстро и легко найти нужную нам запись. Поэтому файлы произвольного доступа очень распространены в различных организациях.

В файлы произвольного доступа можно легко добавлять, удалять записи, не перезаписывая остальные данные. Это очень удобно, так как иногда приходится изменять одну и туже строчку много раз. 

Для записи в текстовый файл последовательного доступа языка c мы использовали функцию fprintf, которая записывала в файл определенное количество символов, в зависимости от длины слова или количества цифр в числе. 

Посмотрим, что делает подобная функция fwrite, которая записывает данные в текстовый файл произвольного доступа.

Функция fwrite всегда, вне зависимости от количества символов или количества цифр, выделяет определенную длину для данного. Эта длина задается в функции. Рассмотрим пример записи в текстовый файл языка С с помощью функции fwrite:

#include <conio.h>
#include <stdio.h>

int main()
{
     int bal;
     FILE *file;

     if ((file = fopen("3.txt","w")) == NULL)
        printf("Файл невозможно открыть или создать\n");
     else{
        for(int i=0; i<5;i++){
           scanf("%d", &bal);
           fwrite (&bal, sizeof(int),1, file );
        }
     }
     fclose(file);
     getch();
return 0;
}

Разберем функцию записи в текстовый файл fwrite досконально:

fwrite (&bal, sizeof(int),1, file );

Первым параметром передаем адрес нашего значения, которое хотим записать в файл (неважно число это или строка); далее вторым параметром следует размер типа нашего данного (в данном случае у нас тип int, что сообщает функции выделять под каждое значение по 2 байта); далее третьим параметром следует количество элементов, которое записывается в файл (если б был массив значений, то могли бы сразу записать несколько элементов); ну, и последним аргументов нашей функции следует указатель на файл, в который будет производиться запись данных

В принципе, больше отличий от записи в файл последовательного доступа здесь не наблюдаем. 
Приступим к чтению данных из файла произвольного доступа:

#include <conio.h>
#include <stdio.h>

int main()
{
     int bal;
     FILE *file = fopen("3.txt","r");

     if (file == NULL)
        printf ("Ошибка при открытии файла");
     else {
        while (!feof(file)){
        fread(&bal, sizeof(int),1, file);
        printf ("%d ", bal);
        }
     }

     fclose(file);
     getch();
return 0;
}

   Функция fread

Давайте теперь разберем отличия функции fread от чтения из файла последовательного доступа:

fread(&bal, sizeof(int),1, file);

Все аргументы функции fread идентичны аргументам fwrite. Только вместо записи в файл данного, содержащегося в переменной bal, происходит записть данного из файла в переменную bal. Иными словами для fwrite - из переменной в файл запись, а для функции fread - из файла в переменную происходит считывание значения. Больше различий нету.



Позиционирование в файле

Каждый открытый файл, как уже отмечалось, имеет скрытый указатель на текущую позицию в нем. При открытии файла этот указатель устанавливается на начало данных, и все операции в файле будут производиться с данными, начинающимися в этой позиции.

При каждом выполнении функции чтения или записи указатель смещается на количество прочитанных или записанных байт, т.е. устанавливается после прочитанного или записанного блока данных в файле – это последовательный доступ к данным.

В языке Си/С++ можно установить указатель на некоторую заданную позицию в файле. Для этого используют стандартную функцию fseek, которая позволяет выполнить чтение или запись данных в произвольном порядке.

Декларация функции позиционирования следующая:

int fseek(FILE *f, long size, int code);

Значение параметра size задает количество байт, на которое необходимо сместить указатель в файле f, в направлении параметра code, который может принимать следующие значения:
– смещение от начала файла – 		(SEEK_SET);
– смещение от текущей позиции – 	(SEEK_CUR);
– смещение от конца файла – 		(SEEK_END).

Таким образом, смещение может быть как положительным, так и отрицательным, но нельзя выходить за пределы файла.

В случае успеха функция возвращает нулевое значение, а в случае ошибки (например, попытка выхода за пределы файла) – единицу.

Доступ к файлу с использованием функции позиционирования (fseek) называют произвольным доступом.

Иногда нужно определить текущее положение в файле. Для этого используют функцию со следующей декларацией:

long ftell(FILE *f);

которая возвращает значение указателя на текущую позицию в файле или –1 в случае ошибки.